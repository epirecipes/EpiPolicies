---
title: "Timestep sensitivity analysis: Exponential vs Euler discretisation"
date: 2026-01-20
author: "Sandra Montes (@slmontes)"
format:
    pdf: 
        mainfont: "Arial"
        sansfont: "Open Sans"
        monofont: "Andale Mono"
        code-overflow: wrap
    docx: default
    html: 
        code-overflow: wrap
    gfm: default
jupyter: julia-quarto-1.11
---

## Introduction

This script performs a timestep sensitivity analysis for Case Scenario 1 (lockdown) comparing two discretisation methods:

**Method 1: Exponential discretisation**

- `infection[t] == (1 - exp(-(1 - υ[t]) * β * I[t] * dt)) * S[t]`
- `recovery[t] == (1 - exp(-γ * dt)) * I[t]`

**Method 2: Simple Euler discretisation**

- `infection[t] == (1 - υ[t]) * β * I[t] * dt * S[t]`
- `recovery[t] == γ * dt * I[t]`

```{julia}
#| echo: true
#| output: false
using JuMP
using Ipopt
using Plots
Plots.default(fmt = :png)   # or :svg
using DataFrames
using Statistics
```

We add a warmup step to trigger JIT compilation and eliminate compilation overhead time

```{julia}
#| echo: true
#| output: false
function warmup_jit()
    warmup_model = Model(Ipopt.Optimizer)
    set_optimizer_attribute(warmup_model, "print_level", 0)  # Silent
    
    # Small test problem
    @variable(warmup_model, 0 <= x[1:5] <= 1)
    @variable(warmup_model, y[1:4] >= 0)
    @constraint(warmup_model, [t=1:4], y[t] == (1 - exp(-0.5 * x[t])) * x[t])
    @constraint(warmup_model, [t=1:4], x[t+1] == x[t] - y[t])
    @objective(warmup_model, Min, x[5])
    
    optimize!(warmup_model)
end
warmup_jit()
```

Model parameters

```{julia}
#| echo: true
#| output: false
β = 0.5         # infection rate
γ = 0.25        # recovery rate
υ_max = 0.5     # maximum intervention
υ_total = 10.0  # maximum cost

t0 = 0.0
tf = 100.0

S0 = 0.99
I0 = 0.01
C0 = 0.00;
```

```{julia}
#| echo: true
#| output: false
# Timesteps to test
dt_values = [2.0, 1.0, 0.5, 0.25, 0.1, 0.05]

# Number of repetitions per dt cases (to calculate mean and std)
n_repetitions = 50

# Initialise results storage
results_exponential = []
results_euler = [];
```

Running optimisation for each timestep on both methods:

### Method 1: Exponential discretisation 

```{julia}
#| echo: true
#| output: false

for dt in dt_values
    
    # Number of time points
    T = Int(tf/dt)

    # Storage results
    solve_times_exp = []
    objectives_exp = []
    statuses_exp = []
    
    # Trajectories 
    local υ_opt_exp, C_opt_exp, S_opt_exp, I_opt_exp
    
    # Run n_repetitions times
    for rep in 1:n_repetitions
        model_exp = Model(Ipopt.Optimizer)
        set_optimizer_attribute(model_exp, "print_level", 0)  
        
        # Variables
        @variable(model_exp, 0 <= S[1:(T+1)] <= 1)
        @variable(model_exp, 0 <= I[1:(T+1)] <= 1)
        @variable(model_exp, 0 <= C[1:(T+1)] <= 1)
        @variable(model_exp, 0 <= υ[1:(T+1)] <= υ_max)
        
        # Exponential discretisation
        @expressions(model_exp, begin
            infection[t in 1:T], (1 - exp(-(1 - υ[t]) * β * I[t] * dt)) * S[t]
            recovery[t in 1:T], (1 - exp(-γ * dt)) * I[t]
        end)

        @constraints(model_exp, begin
            S[1]==S0
            I[1]==I0
            C[1]==C0
            [t=1:T], S[t+1] == S[t] - infection[t]
            [t=1:T], I[t+1] == I[t] + infection[t] - recovery[t]
            [t=1:T], C[t+1] == C[t] + infection[t]
            dt * sum(υ[t] for t in 1:T+1) <= υ_total
        end)
        
        # Objective
        @objective(model_exp, Min, C[T+1])
        
        # Solve and time
        solve_start = time()
        optimize!(model_exp)
        solve_time = time() - solve_start
        
        # Extract results
        status = termination_status(model_exp)
        obj_value = objective_value(model_exp)
        
        # Store results
        push!(solve_times_exp, solve_time)
        push!(objectives_exp, obj_value)
        push!(statuses_exp, status)
        
        # Save trajectories from first run
        if rep == 1
            υ_opt_exp = value.(υ)
            C_opt_exp = value.(C)
            S_opt_exp = value.(S)
            I_opt_exp = value.(I)
        end
    end
    
    # Results
    mean_time_exp = mean(solve_times_exp)
    std_time_exp = std(solve_times_exp)
    
    # Verify ALL runs converged successfully
    if !all(s == MOI.LOCALLY_SOLVED for s in statuses_exp)
        error("Not all Exponential runs converged! Statuses: $statuses_exp")
    end
    status_exp = statuses_exp[1]  # All LOCALLY_SOLVED

    # Verify that all objectives are identical
    if !all(abs(obj - objectives_exp[1]) < 1e-10 for obj in objectives_exp)
        error("Objectives varied across repetitions:\n" *
              "  Values: $objectives_exp\n" *
              "  Max difference: $(maximum(objectives_exp) - minimum(objectives_exp))")
    end
    obj_value_exp = objectives_exp[1]  
    
    # Control 
    threshold = 0.01
    control_start_idx = findfirst(x -> x > threshold, υ_opt_exp)
    control_start_exp = control_start_idx !== nothing ? (control_start_idx - 1) * dt : nothing
    control_active = [υ_opt_exp[i] > threshold for i in 1:length(υ_opt_exp)]
    control_duration_exp = sum(control_active) * dt
    
    # Exponential results
    result_exp = Dict(
        :dt => dt,
        :method => "Exponential",
        :time_points => T+1,
        :objective => obj_value_exp,
        :solve_time => mean_time_exp,
        :solve_time_std => std_time_exp,
        :solve_times_all => solve_times_exp,
        :convergence => string(status_exp),
        :control_start => control_start_exp,
        :control_duration => control_duration_exp,
        :final_infections => C_opt_exp[end],
        :υ_trajectory => υ_opt_exp,
        :C_trajectory => C_opt_exp,
        :S_trajectory => S_opt_exp,
        :I_trajectory => I_opt_exp
    )
    push!(results_exponential, result_exp)
end
```

## Method 2: Simple Euler discretisation (Linear approximation)

```{julia}
#| echo: true
#| output: false

for dt in dt_values
    
    # Number of time points
    T = Int(tf/dt)
    
    # Storage results
    solve_times_euler = [] 
    objectives_euler = []
    statuses_euler = []
    
    # Trajectories 
    local υ_opt_euler, C_opt_euler, S_opt_euler, I_opt_euler
    
    # Run n_repetitions times
    for rep in 1:n_repetitions
        model_euler = Model(Ipopt.Optimizer)
        set_optimizer_attribute(model_euler, "print_level", 0)  
        
        # Variables
        @variable(model_euler, 0 <= S[1:(T+1)] <= 1)
        @variable(model_euler, 0 <= I[1:(T+1)] <= 1)
        @variable(model_euler, 0 <= C[1:(T+1)] <= 1)
        @variable(model_euler, 0 <= υ[1:(T+1)] <= υ_max)
        
        # Simple Euler discretisation
        @expressions(model_euler, begin
            infection[t in 1:T], (1 - υ[t]) * β * I[t] * dt * S[t]
            recovery[t in 1:T], γ * dt * I[t]
        end)

        @constraints(model_euler, begin
            S[1]==S0
            I[1]==I0
            C[1]==C0
            [t=1:T], S[t+1] == S[t] - infection[t]
            [t=1:T], I[t+1] == I[t] + infection[t] - recovery[t]
            [t=1:T], C[t+1] == C[t] + infection[t]
            dt * sum(υ[t] for t in 1:T+1) <= υ_total
        end)
        
        # Objective
        @objective(model_euler, Min, C[T+1])
        
        # Solve and time
        solve_start = time()
        optimize!(model_euler)
        solve_time = time() - solve_start
        
        # Extract results
        status = termination_status(model_euler)
        obj_value = objective_value(model_euler)
        
        # Store results
        push!(solve_times_euler, solve_time)
        push!(objectives_euler, obj_value)
        push!(statuses_euler, status)
        
        # Save trajectories from first run
        if rep == 1
            υ_opt_euler = value.(υ)
            C_opt_euler = value.(C)
            S_opt_euler = value.(S)
            I_opt_euler = value.(I)
        end
    end
    
    # Calculate statistics
    mean_time_euler = mean(solve_times_euler)
    std_time_euler = std(solve_times_euler)
    
    # Verify ALL runs converged successfully
    if !all(s == MOI.LOCALLY_SOLVED for s in statuses_euler)
        error("Not all Euler runs converged! Statuses: $statuses_euler")
    end
    status_euler = statuses_euler[1]  

    # Verify all objectives are identical
    if !all(abs(obj - objectives_euler[1]) < 1e-10 for obj in objectives_euler)
        error("Objectives varied across repetitions:\n" *
              "  Values: $objectives_euler\n" *
              "  Max difference: $(maximum(objectives_euler) - minimum(objectives_euler))")
    end
    obj_value_euler = objectives_euler[1]  
    
    # Control 
    threshold = 0.01
    control_start_idx = findfirst(x -> x > threshold, υ_opt_euler)
    control_start_euler = control_start_idx !== nothing ? (control_start_idx - 1) * dt : nothing
    control_active = [υ_opt_euler[i] > threshold for i in 1:length(υ_opt_euler)]
    control_duration_euler = sum(control_active) * dt
    
    # Verify all objectives are identical
    if !all(abs(obj - objectives_euler[1]) < 1e-10 for obj in objectives_euler)
        error("Euler: Not deterministic! Objectives varied across repetitions:\n" *
              "  Values: $objectives_euler\n" *
              "  Max difference: $(maximum(objectives_euler) - minimum(objectives_euler))")
    end
    
    # Euler results
    result_euler = Dict(
        :dt => dt,
        :method => "Euler",
        :time_points => T+1,
        :objective => obj_value_euler,
        :solve_time => mean_time_euler,
        :solve_time_std => std_time_euler,
        :solve_times_all => solve_times_euler,
        :convergence => string(status_euler),
        :control_start => control_start_euler,
        :control_duration => control_duration_euler,
        :final_infections => C_opt_euler[end],
        :υ_trajectory => υ_opt_euler,
        :C_trajectory => C_opt_euler,
        :S_trajectory => S_opt_euler,
        :I_trajectory => I_opt_euler
    )
    push!(results_euler, result_euler)
end
```

```{julia}
#| echo: false
#| output: false

# Create dataframes for results
results_exp_df = DataFrame(
    dt = [r[:dt] for r in results_exponential],
    time_points = [r[:time_points] for r in results_exponential],
    objective = [r[:objective] for r in results_exponential],
    solve_time_mean = [r[:solve_time] for r in results_exponential],
    solve_time_std = [r[:solve_time_std] for r in results_exponential],
    convergence = [r[:convergence] for r in results_exponential],
    control_start = [r[:control_start] for r in results_exponential],
    control_duration = [r[:control_duration] for r in results_exponential],
    final_infections = [r[:final_infections] for r in results_exponential]
)

results_euler_df = DataFrame(
    dt = [r[:dt] for r in results_euler],
    time_points = [r[:time_points] for r in results_euler],
    objective = [r[:objective] for r in results_euler],
    solve_time_mean = [r[:solve_time] for r in results_euler],
    solve_time_std = [r[:solve_time_std] for r in results_euler],
    convergence = [r[:convergence] for r in results_euler],
    control_start = [r[:control_start] for r in results_euler],
    control_duration = [r[:control_duration] for r in results_euler],
    final_infections = [r[:final_infections] for r in results_euler]
)

# Create comparison DataFrame
comparison_df = DataFrame(
    dt = [r[:dt] for r in results_exponential],
    obj_exp = [r[:objective] for r in results_exponential],
    obj_euler = [r[:objective] for r in results_euler],
    obj_diff = [abs(results_exponential[i][:objective] - results_euler[i][:objective]) for i in 1:length(results_exponential)],
    method_diff_pct = [abs(results_exponential[i][:objective] - results_euler[i][:objective]) / results_exponential[i][:objective] * 100 for i in 1:length(results_exponential)],
    time_exp_mean = [r[:solve_time] for r in results_exponential],
    time_exp_std = [r[:solve_time_std] for r in results_exponential],
    time_euler_mean = [r[:solve_time] for r in results_euler],
    time_euler_std = [r[:solve_time_std] for r in results_euler]
)
```

Exponential discretisation results:

```{julia}
#| echo: false
#| output: true
# Round numeric columns to 4 digits for display
show(transform(results_exp_df, names(results_exp_df, Real) .=> (x -> round.(x, digits=4)) .=> names(results_exp_df, Real)), allrows=true, allcols=true)
```

Simple Euler discretisation results:

```{julia}
#| echo: false
#| output: true
# Round numeric columns to 4 digits for display
show(transform(results_euler_df, names(results_euler_df, Real) .=> (x -> round.(x, digits=4)) .=> names(results_euler_df, Real)), allrows=true, allcols=true)
```

Relative errors of each method using 'dt=0.05' as reference

```{julia}
#| echo: true
#| output: true

ref_idx_exp = findfirst(r -> r[:dt] == 0.05, results_exponential)
ref_idx_euler = findfirst(r -> r[:dt] == 0.05, results_euler)

if ref_idx_exp !== nothing && ref_idx_euler !== nothing
    ref_obj_exp = results_exponential[ref_idx_exp][:objective]
    ref_obj_euler = results_euler[ref_idx_euler][:objective]
     
    # Exponential method
    rel_errors_exp = []
    for r in results_exponential
        obj_error = abs(r[:objective] - ref_obj_exp) / ref_obj_exp * 100
        push!(rel_errors_exp, Dict(
            :dt => r[:dt],
            :obj_rel_error_pct => obj_error,
            :method => "Exponential"
        ))
    end
    
    # Euler method
    rel_errors_euler = []
    for r in results_euler
        obj_error = abs(r[:objective] - ref_obj_euler) / ref_obj_euler * 100
        push!(rel_errors_euler, Dict(
            :dt => r[:dt],
            :obj_rel_error_pct => obj_error,
            :method => "Euler"
        ))
    end
    
    errors_exp_df = DataFrame(rel_errors_exp)
    errors_euler_df = DataFrame(rel_errors_euler)
    
    # Convergence table
    convergence_comparison_df = DataFrame(
        dt = [r[:dt] for r in results_exponential],
        exp_error_pct = [r[:obj_rel_error_pct] for r in rel_errors_exp],
        euler_error_pct = [r[:obj_rel_error_pct] for r in rel_errors_euler]
    )
    
    show(transform(convergence_comparison_df, names(convergence_comparison_df, Real) .=> (x -> round.(x, digits=4)) .=> names(convergence_comparison_df, Real)), allrows=true, allcols=true)
    
end
```

### Plots

```{julia}
#| echo: false
#| output: true
#| fig-format: png
# Objective value vs timestep
p1 = plot(
    xlabel="Timestep (dt)",
    ylabel="Optimal Objective Value",
    title="Objective convergence: Exponential vs Euler",
    legend=:topleft,
    grid=true
)
plot!(p1, [r[:dt] for r in results_exponential], [r[:objective] for r in results_exponential],
    marker=:circle, linewidth=2, markersize=6, label="Exponential", color=:blue)
plot!(p1, [r[:dt] for r in results_euler], [r[:objective] for r in results_euler],
    marker=:square, linewidth=2, markersize=6, label="Euler", color=:red)

# Relative difference between methods
p2 = plot(
    [r[:dt] for r in results_exponential],
    [abs(results_exponential[i][:objective] - results_euler[i][:objective]) / results_exponential[i][:objective] * 100 for i in 1:length(results_exponential)],
    marker=:diamond,
    linewidth=2,
    markersize=6,
    xlabel="Timestep (dt)",
    ylabel="Relative Difference (%)",
    title="Method difference: |Exp - Euler| / Exp × 100%",
    legend=false,
    grid=true,
    color=:purple
)

# Solve time comparison
p3 = plot(
    xlabel="Number of Time Points",
    ylabel="Solve Time (seconds)",
    title="Computational scaling (mean ± std, n=$n_repetitions runs)",
    legend=:topleft,
    grid=true,
    xscale=:log10
)

# Plot with error bars
plot!(p3, [r[:time_points] for r in results_exponential], 
          [r[:solve_time] for r in results_exponential],
          yerror=[r[:solve_time_std] for r in results_exponential],
          marker=:circle, linewidth=2, markersize=6, 
          label="Exponential", color=:blue)

plot!(p3, [r[:time_points] for r in results_euler], 
          [r[:solve_time] for r in results_euler],
          yerror=[r[:solve_time_std] for r in results_euler],
          marker=:square, linewidth=2, markersize=6, 
          label="Euler", color=:red)

# Control trajectories comparison for timestep dt = 0.5
dt_compare = 0.5
idx_compare = findfirst(r -> r[:dt] == dt_compare, results_exponential)
if idx_compare !== nothing
    p4 = plot(
        xlabel="Time (days)",
        ylabel="Control Value (υ)",
        title="Control trajectories comparison (dt = $dt_compare)",
        legend=:topright,
        grid=true
    )
    
    ts = collect(0:dt_compare:tf)
    υ_exp = results_exponential[idx_compare][:υ_trajectory]
    υ_euler = results_euler[idx_compare][:υ_trajectory]
    
    plot!(p4, ts, υ_exp, linewidth=3, label="Exponential", color=:blue, alpha=0.7)
    plot!(p4, ts, υ_euler, linewidth=3, label="Euler", color=:red, alpha=0.7, linestyle=:dash)
else
    p4 = plot(title="Control comparison not available")
end

plot(p1, p2, p3, p4, layout=(2,2), size=(1200, 900))
```

```{julia}
#| echo: false
#| output: false
#| fig-format: png
# Create the combined plot
combined_plot = plot(p1, p2, p3, p4, layout=(2,2), size=(1200, 900))

# Save it
savefig(combined_plot, "FigS3.png")
```

